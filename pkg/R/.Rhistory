sigma_Q = Daretest$sigma_Q, alpha = Daretest$alpha[dim(Daretest$alpha)[1],1], mvec = Daretest$mvec[dim(Daretest$mvec)[1],],
betas = 2, nvec = rep(1/length(Dare$vocab), length(Dare$vocab)), prior.b.mean = rep(0,24), prior.b.var = diag(24),
prior.delta = c(0, 1), out = 1, n_B = 5500, n_d = 550, burn = c(500, 50), thinning = c(10, 1), netstat = c("dyadic", "degree", "triadic"),
optimize = TRUE, initial = initial, Daretest)
filename = paste0("PPC", i, "_nIP2_K25_Dare.RData")
save(PPC, file = filename)
}
library(IPTM2)
setwd('/Users/bomin8319/Desktop/IPTM/full')
load('Darenew.RData')
# 762 -
attach(Dare)
Dare$node = 1:nrow(Dare$node)
Dare$edge = Dare$edge[-which(sapply(Dare$text, function(d){length(d)})==0)]
Dare$text = Dare$text[-which(sapply(Dare$text, function(d){length(d)})==0)]
mintime = Dare$edge[[1]][[3]]
for (n in 1:length(Dare$edge)){
Dare$edge[[n]][3] = (Dare$edge[[n]][[3]] - mintime) / 3600
}
Dare$edge = lapply(Dare$edge, function(x){x[1:3]})
setwd('~/Desktop/IPTM/full')
for (i in 5:5) {
filename = paste0("Dare_full_",2,"_",25,"_ver",i,".RData")
load(filename)
nIP = 2
K = 25
initial = list()
initial$alpha =  Daretest$alpha[dim(Daretest$alpha)[1],1]
initial$mvec = Daretest$mvec[dim(Daretest$mvec)[1],]
initial$delta = Daretest$D[length(Daretest$D)]
initial$eta = Daretest$E[length(Daretest$E)]
initial$b = lapply(1:nIP, function(IP) {
Daretest$B[[IP]][,ncol(Daretest$B[[IP]])]
})
initial$C = Daretest$C
initial$Z = Daretest$Z
initial$bmat = Daretest$B
initial$dmat = Daretest$D
initial$emat = Daretest$E
initial$proposal.var = Daretest$proposal.var
initial$iJi = Daretest$iJi
initial$sigma_Q = Daretest$sigma_Q
PPC = IPTM_check.data(O = 20, edge = Dare$edge, node = Dare$node, textlist = Dare$text, vocabulary = Dare$vocab, nIP = nIP, K = K,
sigma_Q = Daretest$sigma_Q, alpha = Daretest$alpha[dim(Daretest$alpha)[1],1], mvec = Daretest$mvec[dim(Daretest$mvec)[1],],
betas = 2, nvec = rep(1/length(Dare$vocab), length(Dare$vocab)), prior.b.mean = rep(0,24), prior.b.var = diag(24),
prior.delta = c(0, 1), out = 1, n_B = 5500, n_d = 550, burn = c(500, 50), thinning = c(10, 1), netstat = c("dyadic", "degree", "triadic"),
optimize = TRUE, initial = initial, Daretest)
filename = paste0("PPC", i, "_nIP2_K25_Dare.RData")
save(PPC, file = filename)
}
N = 1000
X = rep(1, N)
rs2_fc = function(Y, X, beta) {
E = Y - X * beta
s2 = 1 / rgamma(1, 2 + length(E) / 2, 1 + sum(E^2) / 2)
return(s2)
}
rbeta_fc = function(Y, X, beta, tau, s2) {
var = 1 / (t(X)%*%X / s2 + 1 /tau)
mean = t(Y)%*%X / s2
beta = rnorm(1, var * mean, sqrt(var))
return(beta)
}
BLR = function(Y, X) {
s2out = c()
tauout = c()
betaout = c()
beta = 0
for (nsim in 1:1000) {
s2 = rs2_fc(Y, X, beta)
tau = 1 / rgamma(1, 2 + 1/2, 1 + beta^2 / 2)
beta = rbeta_fc(Y, X, beta, tau, s2)
s2out[nsim] = s2
tauout[nsim] = tau
betaout[nsim] = beta
}
return(cbind(s2out, tauout, betaout))
}
library(MCMCpack)
covsim = c()
for (sims in 1:100) {
cov = 0
for (i in 1:100) {
tau = 1/rgamma(1, 2, 1)
beta = rnorm(1, 0, sqrt(tau))
s2 = 1/rgamma(1, 2, 1)
errors = rnorm(N, 0, sqrt(s2))
Y = X * beta + errors
Est = BLR(Y, X)
HPD = HPDinterval(mcmc(Est[-1:-100, 1]))
cov = cov + as.numeric(HPD[1,1] <= s2 & HPD[1,2] >= s2)
}
covsim[sims] = cov
}
covsinms
covsims
library(MCMCpack)
covsim = c()
for (sims in 1:1) {
cov = 0
for (i in 1:100) {
tau = 1/rgamma(1, 2, 1)
beta = rnorm(1, 0, sqrt(tau))
s2 = 1/rgamma(1, 2, 1)
errors = rnorm(N, 0, sqrt(s2))
Y = X * beta + errors
Est = BLR(Y, X)
HPD = HPDinterval(mcmc(Est[-1:-100, 1]))
cov = cov + as.numeric(HPD[1,1] <= s2 & HPD[1,2] >= s2)
}
covsim[sims] = cov
}
covsim
library(stmgui)
install.packages("stmgui")
runStmGui()
librarY(stmgui)
library(stmgui)
runStmGui()
library(DT)
install.packages("DT")
runStmGui()
library(survival)
ggkm
?ggkm
library(ggplot2)
ggkm
?ggkm
??ggkm
#’ Create a Kaplan-Meier plot using ggplot2
#’
#’ @param sfit a \code{\link[survival]{survfit}} object
#’ @param returns logical: if \code{TRUE}, return an ggplot object
#’ @param xlabs x-axis label
#’ @param ylabs y-axis label
#’ @param ystratalabs The strata labels. \code{Default = levels(summary(sfit)$strata)}
#’ @param ystrataname The legend name. Default = “Strata”
#’ @param timeby numeric: control the granularity along the time-axis
#’ @param main plot title
#’ @param pval logical: add the pvalue to the plot?
#’ @return a ggplot is made. if returns=TRUE, then an ggplot object
#’ is returned
#’ @author Abhijit Dasgupta with contributions by Gil Tomas
#’ \url{http://statbandit.wordpress.com/2011/03/08/an-enhanced-kaplan-meier-plot/}
#’ @export
#’ @examples
#’ \dontrun{
#’ data(colon)
#’  fit <- survfit(Surv(time,status)~rx, data=colon)
#'  ggkm(fit, timeby=500)
#' }
ggkm <- function(sfit, returns = FALSE,
xlabs = "Time", ylabs = "survival probability",
ystratalabs = NULL, ystrataname = NULL,
timeby = 100, main = "Kaplan-Meier Plot",
pval = TRUE, ...) {
require(plyr)
require(ggplot2)
require(survival)
require(gridExtra)
if(is.null(ystratalabs)) {
ystratalabs <- as.character(levels(summary(sfit)$strata))
}
m <- max(nchar(ystratalabs))
if(is.null(ystrataname)) ystrataname <- "Strata"
times <- seq(0, max(sfit$time), by = timeby)
.df <- data.frame(time = sfit$time, n.risk = sfit$n.risk,
n.event = sfit$n.event, surv = sfit$surv, strata = summary(sfit, censored = T)$strata,
upper = sfit$upper, lower = sfit$lower)
levels(.df$strata) <- ystratalabs
zeros <- data.frame(time = 0, surv = 1, strata = factor(ystratalabs, levels=levels(.df$strata)),
upper = 1, lower = 1)
.df <- rbind.fill(zeros, .df)
d <- length(levels(.df$strata))
p <- ggplot(.df, aes(time, surv, group = strata)) +
geom_step(aes(linetype = strata), size = 0.7) +
theme_bw() +
theme(axis.title.x = element_text(vjust = 0.5)) +
scale_x_continuous(xlabs, breaks = times, limits = c(0, max(sfit$time))) +
scale_y_continuous(ylabs, limits = c(0, 1)) +
theme(panel.grid.minor = element_blank()) +
theme(legend.position = c(ifelse(m < 10, .28, .35), ifelse(d < 4, .25, .35))) +
theme(legend.key = element_rect(colour = NA)) +
labs(linetype = ystrataname) +
theme(plot.margin = unit(c(0, 1, .5, ifelse(m < 10, 1.5, 2.5)), "lines")) +
ggtitle(main)
if(pval) {
sdiff <- survdiff(eval(sfit$call$formula), data = eval(sfit$call$data))
pval <- pchisq(sdiff$chisq, length(sdiff$n)-1, lower.tail = FALSE)
pvaltxt <- ifelse(pval < 0.0001, "p < 0.0001", paste("p =", signif(pval, 3)))
p <- p + annotate("text", x = 0.6 * max(sfit$time), y = 0.1, label = pvaltxt)
}
## Plotting the graphs
print(p)
if(returns) return(p)
}
ggkm
library(bayesSurv)
install.packages("bayesSurv")
library(bayesSurv)
data(colon)
fit <- survfit(Surv(time,status)~rx, data=colon)
fit
names(fit)
fit$surv
fit$n
names(fit)
fit$time
length(fit$time)
length(fit$n.risk)
length(fit$n.event)
fit$n.event
length(fit$surv)
fit$surv
?survfit
fit$strata
summary(sfit, censored = T)$strata
summary(fit, censored = T)$strata
names(fit)
fit$upper
fit$lower
ggkm(fit, timeby=500)
library(survival) 				data(colon)
fit <- survfit(Surv(time,status)~rx, data=colon)
data(colon)
fit <- survfit(Surv(time,status)~rx, data=colon)
library(survival)
data(colon)
fit <- survfit(Surv(time,status)~rx, data=colon)
names(fit)
fit$surv
survfit
?survfit
?survfit.object
library(survival)
data(colon)
fit <- survfit(Surv(time,status)~rx, data=colon)
names(fit)
fit$strata
colon
dim(colon)
summary(fit, censored = T)$strata
library(survival) 				data(colon)
fit <- survfit(Surv(time,status)~rx, data=colon)
library(survival)
data(colon)
head(colon)
fit <- survfit(Surv(time,status)~rx+sex, data=colon)
fit$strata
summary(fit, censored = T)$strata
dim(summary(sfit, censored = T)$strata)
length(summary(fit, censored = T)$strata)
dim(colon)
dim(summary(sfit, censored = T)$strata)
dim(summary(fit, censored = T)$strata)
class(summary(fit, censored = T)$strata)
summary(fit)
names(fit)
fit$n
sum(fit$n)
length(fit$strata)
fit$strata
sum(fit$strata)
colon
dim(colon)
sum(is.na(colon))
dim(unique(colon[,3:4]))
unique(colon[,3:4])
colon[unique(colon[,3:4]),]
sum(is.na(colon[,3]))
sum(is.na(colon[,4]))
fit$n.censor
length(fit$n.censor)
sfit <- survfit(Surv(time,status)~rx+sex, data=colon)
library(survival)
data(colon)
sfit <- survfit(Surv(time,status)~rx+sex, data=colon)
ggkm(fit, timeby=500)
sfit$strata
summary(sfit)$strata
length(summary(sfit)$strata)
length(summary(sfit, censored = T)$strata)
library(survival)
data(colon)
sfit <- survfit(Surv(time,status)~rx+sex, data=colon)
strata <- summary(sfit, censored = T)$strata
strata
length(strata)
load("/Users/bomin8319/Desktop/DLFM/UN_full.RData")
names(UN)
plot(UN$kappas[,1])
plot(UN$kappas[,1], type = 'l')
plot(UN$kappas[,2], type = 'l')
plot(UN$kappas[,3], type = 'l')
plot(UN$kappas[,4], type = 'l')
plot(UN$kappas[,5], type = 'l')
plot(UN$kappas[,6], type = 'l')
plot(UN$kappas[,7], type = 'l')
plot(UN$tau[,1], type = 'l')
plot(UN$tau[,2], type = 'l')
plot(UN$tau[,3], type = 'l')
plot(UN$tau[,4], type = 'l')
plot(UN$tau[,5], type = 'l')
plot(UN$tau[,6], type = 'l')
plot(UN$tau[,7], type = 'l')
plot(UN$tau[,8], type = 'l')
plot(UN$tau[,9], type = 'l')
plot(UN$tau[,10], type = 'l')
UN$corr
GPpost
library(DLFM2)
GPpost
names(UN)
head(UN$tau)
setwd('/Users/bomin8319/Desktop/DLFM/pkg2')
document()
library(devtools)
document(
)
document(
)
check()
install()
load("/Users/bomin8319/Desktop/DLFM/UNfit/UNdatafull.RData")
attach(UNdatafull)
library(FastGP)
library(mvtnorm)
library(fields)
library(reshape)
library(MCMCpack)
library(expm)
library(igraph)
library(DLFM2)
library(coda)
library(ggplot2)
library(gridExtra)
ggplotColours <- function(n = 6, h = c(0, 360) + 15){
if ((diff(h) %% 360) < 1) h[2] <- h[2] - 360/n
hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
}
number_ticks <- function(n) {function(limits) pretty(limits, n)}
for(tp in 1:32){
diag(X[tp,,,2]) = 0
}
load("/Users/bomin8319/Desktop/DLFM/UNfit/clang.RData")
rownames(clang)[36] = "GFR"
reduced <-which(dimnames(Y)[[2]] %in% c(intersect(rownames(clang), rownames(Y[1,,])), "IRQ", "GRG"))
Y = Y[, reduced, reduced]
X = X[, reduced, reduced, 1:5]
clang2 = matrix(NA, 74, 74)
rownames(clang2) = colnames(clang2)=rownames(Y[1,,])
diag(clang) = 1
Xnew = array(NA, dim = c(32,74,74,6))
dimnames(Xnew)[1] =dimnames(X)[1]
dimnames(Xnew)[2] =dimnames(X)[2]
dimnames(Xnew)[3] =dimnames(X)[3]
dimnames(Xnew)[[4]] = c("intercept", "log(distance)", "polity", "alliance", "Trade/GDP", "language")
Xnew[,,,1:5] = X[,,,1:5]
order = rep(NA, 74)
for (i in 1:74){
if (rownames(Y[1,,])[i] %in% rownames(clang) ) {
order[i] = which(rownames(clang)==rownames(Y[1,,])[i])
}
}
order2 = order[!is.na(order)]
clang2[-c(72, 29), -c(72, 29)] = clang[order2,order2]
clang2[29, ] = clang2[31,]
clang2[,29] = clang2[,31]
clang2[72,] = 0
clang2[,72]  =0
diag(clang2)= 1
# 74 country version
# not existing countries -> all missing values imputed using model (biased)
avail1 = matrix(1, 32, 74)
avail1[1:8, c(71, 36)] =0 #North and South Korea did not joined UN voting until 1990
avail1[1:10, 72] = 0 #GRG no voted until 1992
avail1[1:9, 73] = 0 #RUS X variables not existed until 1991
avail1[1:9, 74] = 0 #UKR not existed until 1991
avail1[13:21, 29] = 0 #IRQ under sanction
for (t in 1:32){
Xnew[t,,,6] = clang2
}
Time = 32
N = 74
Degrees = vapply(1:Time, function(tp) {rowSums(Y[tp,,], na.rm = TRUE)}, rep(0, N))
corr = vapply(1:31, function(l) {cor(Degrees[1:(N*(Time - l))], Degrees[(1 + N*l):(N*Time)], use = "complete")}, 0)
plot(corr, type = 'l')
UN = DLFM_MH2(Y[1:32,,], Xnew[1:32,,,1:6], RE = c("additive", "multiplicative"), R = 2, avail = avail1, burn = 1000, nscan = 5000, odens = 10, plot = FALSE)
names(UN)
plot(UN$tau[,1], type = 'l')
plot(UN$tau[,2], type = 'l')
plot(UN$tau[,3], type = 'l')
plot(UN$tau[,4], type = 'l')
plot(UN$tau[,5], type = 'l')
plot(UN$tau[,6], type = 'l')
plot(UN$tau[,7], type = 'l')
plot(UN$tau[,8], type = 'l')
plot(UN$tau[,9], type = 'l')
plot(UN$kappas[,1], type = 'l')
plot(UN$kappas[,2], type = 'l')
plot(UN$kappas[,3], type = 'l')
plot(UN$kappas[,4], type = 'l')
plot(UN$kappas[,5], type = 'l')
plot(UN$kappas[,6], type = 'l')
plot(UN$kappas[,7], type = 'l')
plot(UN$kappas[,8], type = 'l')
plot(UN$kappas[,9], type = 'l')
plot(UN$s2, type = 'l')
UNnew = UN
plot(UNnew$s2, type = 'l')
load("/Users/bomin8319/Desktop/DLFM/UN_full.RData")
plot(UN$s2, type = 'l')
par(mfrow=c(2,1))
plot(UN$s2, type = 'l')
plot(UNnew$s2, type = 'l')
mean(UNnew$s2)
mean(UN$s2)
plot(UN$tau[,8], type = 'l')
plot(UNnew$tau[,8], type = 'l')
load("/Users/bomin8319/Desktop/DLFM/UN_full2.RData")
plot(UN2$kappas[,9], type = 'l')
plot(UN2$kappas[,8], type = 'l')
plot(UN2$kappas[,7], type = 'l')
GPpost
load("/Users/bomin8319/Desktop/UN_DAME.RData")
library(devtools)
setwd('/Users/bomin8319/Desktop/DAME/pkg/R')
load_all()
load("/Users/bomin8319/Desktop/DAME/UNdatafull.RData")
attach(UNdatafull)
library(FastGP)
library(mvtnorm)
library(fields)
library(reshape)
library(MCMCpack)
library(expm)
library(igraph)
library(DLFM2)
library(coda)
library(ggplot2)
library(gridExtra)
ggplotColours <- function(n = 6, h = c(0, 360) + 15){
if ((diff(h) %% 360) < 1) h[2] <- h[2] - 360/n
hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
}
number_ticks <- function(n) {function(limits) pretty(limits, n)}
# 74 country version
# not existing countries -> all missing values imputed using model (biased)
avail1 = matrix(1, 32, 74)
avail1[1:8, c(71, 36)] =0 #North and South Korea did not joined UN voting until 1990
avail1[1:10, 72] = 0 #GRG no voted until 1992
avail1[1:9, 73] = 0 #RUS X variables not existed until 1991
avail1[1:9, 74] = 0 #UKR not existed until 1991
avail1[13:21, 29] = 0 #IRQ under sanction
Time = 32
N = 74
Degrees = vapply(1:Time, function(tp) {rowSums(Y[tp,,], na.rm = TRUE)}, rep(0, N))
corr = vapply(1:31, function(l) {cor(Degrees[1:(N*(Time - l))], Degrees[(1 + N*l):(N*Time)], use = "complete")}, 0)
plot(corr, type = 'l')
#correlations
p = list()
cordata = data.frame(rbind(UN$corr[,1:3]), c(rep("DAME", 500)))
colnames(cordata) = c("Lag1", "Lag2", "Lag3", "Model")
p[[1]] = ggplot(cordata, aes(x = Lag1, fill = Model, color = Model)) + geom_histogram(position = "identity", alpha = 0.5) + geom_vline(aes(xintercept = vapply(1:1, function(l) {cor(Degrees[1:(N*(Time - l))], Degrees[(1 + N*l):(N*Time)], use = "complete")}, 0)), col = "blue", size = 1) +theme_minimal() +theme(legend.position = "bottom")
p[[2]] = ggplot(cordata, aes(x = Lag2, fill = Model, color = Model)) + geom_histogram(position = "identity", alpha = 0.5) + geom_vline(aes(xintercept = vapply(2:2, function(l) {cor(Degrees[1:(N*(Time - l))], Degrees[(1 + N*l):(N*Time)], use = "complete")}, 0)), col = "blue", size = 1)  + theme_minimal()
p[[3]] = ggplot(cordata, aes(x = Lag3, fill = Model, color = Model)) + geom_histogram(position = "identity", alpha = 0.5) + geom_vline(aes(xintercept = vapply(3:3, function(l) {cor(Degrees[1:(N*(Time - l))], Degrees[(1 + N*l):(N*Time)], use = "complete")}, 0)), col = "blue", size = 1) +theme_minimal()+ theme(legend.position = "top")
marrangeGrob(p[1:3], nrow = 1, ncol = 3, top = NULL)
g_legend<-function(a.gplot){
tmp <- ggplot_gtable(ggplot_build(a.gplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
return(legend)}
mylegend<-g_legend(p[[1]])
p3 <- grid.arrange(arrangeGrob(p[[1]] + theme(legend.position="none"),
p[[2]] + theme(legend.position="none"),
p[[3]] + theme(legend.position="none"), nrow=1),
mylegend, heights=c(10, 1))
#beta
beta = lapply(1:32, function(t){summary(mcmc(UN$BETA[[t]][1:500,]))[[2]]})
betas = list()
for (i in 1:6) {betas[[i]] = sapply(1:32, function(t){beta[[t]][i,]})}
betacols= ggplotColours(6)
plots = list()
i= 1
years = c(1983:2014)
data = data.frame(cbind(years,t(betas[[i]])))
colnames(data)[4] = "beta"
f = ggplot(data, aes(x = years))
plots[[1]]=f + geom_line(aes(y = beta), colour=betacols[1]) + geom_ribbon(aes(ymin = X2.5., ymax = X97.5.), alpha = 0.1) + scale_x_continuous(breaks=number_ticks(8))+ylab("Intercept") + theme_minimal()
color =betacols[-1]
varname = c("log(distance)", "Polity", "Alliance", "Lower trade-to-GDP ratio", "Common Language")
for (i in 2:6){
years = c(1983:2014)
data = data.frame(cbind(years,t(betas[[i]])))
colnames(data)[4] = "beta"
f = ggplot(data, aes(x = years))
plots[[i]] <- f + geom_line(aes(y = beta), colour=color[i-1]) + geom_ribbon(aes(ymin = X2.5., ymax = X97.5.), alpha = 0.1) + ylab(varname[i-1]) + scale_x_continuous(breaks=number_ticks(8)) + geom_hline(yintercept = 0) + theme_minimal()
}
marrangeGrob(plots[1:6], nrow = 2, ncol = 3, top = NULL)
#thetaplot
colors = sort(rownames(UN$U[[32]]))
colors[which(colors == "GFR")] = "GMY"
rownames(UN$U[[32]])[22] = "GMY"
thetanew = t(sapply(1:32, function(t){colMeans(UN$theta[[t]])}))
orders = sapply(1:74, function(n){which(colors[n]== rownames(UN$U[[32]]))})
thetanew = thetanew[,orders]
data3 = data.frame(years = years, theta = thetanew)
colnames(data3)[-1] = colors
data3new = melt(data3, id = "years")
colnames(data3new)[3] = "theta"
f <- ggplot(data3new, aes(years, theta, colour = variable, label = variable))
f + geom_line() + scale_x_continuous(breaks=number_ticks(8)) + scale_colour_discrete(name = "countries") + theme_minimal()
