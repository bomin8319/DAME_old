library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
rd_fc(XB, theta, U, d, Y, s2, meaningful_NA)
XB
meaningful_NA
s2
d
U
rd_fc(XB, theta, U, d, Y, s2, meaningful_NA)
meaningful_NA
Time = nrow(theta)#
  R = ncol(d)#
  N = ncol(theta)#
  uppertri = upper.tri(diag(N))#
  UUr2 = c()#
  E_r2 = c()#
  d = d#
  E = lapply(1:Time, function(tp) {#
    Y[tp, , ] - XB[[tp]] - outer(theta[tp,], theta[tp,], "+")#
  })
r
r = 1
tp = 1
UUr = U[tp, , r] %*% t(U[tp, , r])
UDU_r = d[tp, -r] * U[tp, , -r] %*% t(U[tp, , -r])
UUr[meaningful_NA[[tp]]] = NA
EU =  (E[[tp]] - UDU_r) * UUr#
  		UUr2[tp] = sum(UUr[uppertri]^2, na.rm = TRUE)#
  		E_r2[tp] = sum(EU[uppertri], na.rm = TRUE)
invvar = rcppeigen_invert_matrix(cinv + diag(UUr2) / s2)#
    mu = E_r2 / s2
cinv
Q
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    #tau_r = rtaur_fc(d, cinv[[P+2]], a, b)#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    }       #
    browser()#
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
Q
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    }       #
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
sim
mean(sim$UDU[[4]])
mean(sim$UDU[[4]])/6
document9
document()
document()
install()
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    }       #
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
sim
plot(M4$s2, type = ;l)
plot(M4$s2, type = 'l')
s2
document()
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
sim
document()
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
sim
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
L
(apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i])
Q
instalL()
install()
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    }       #
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    browser()#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
d
U
Time = nrow(theta)#
  R = ncol(d)#
  N = ncol(theta)#
  U = U#
  E = lapply1(1:Time, function(tp) {#
    Y[tp, , ] - XB[[tp]] - outer(theta[tp,], theta[tp,], "+")#
  })
E = lapply(1:Time, function(tp) {#
    Y[tp, , ] - XB[[tp]] - outer(theta[tp,], theta[tp,], "+")#
  })
tp = 1
i = 1
L = diag(d[tp, ])
:
L
(apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i])
L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2
1.637714 * -0.1012607
(diag(R) / tau_r
)
diag(R) / tau_r
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
r = 1
tp
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
r = 2
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
E[[tp]][i, -i]
E_i = E[[tp]][i, -i]
E_i
sum(E_i * d[tp, r] * U[tp, -i , r], na.rm = TRUE)
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
diag(DUr2)
for (tp in 1:Time) {#
      		DUr2[tp] = sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)}
diag(DUr2)
DUr2 = c()
for (tp in 1:Time) {#
      		DUr2[tp] = sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)}
diag(DUr2)
rmatrixnorm(M, U, V)
diag(Time) / tau_r
tau_r
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2
sum((diag(d[tp, ]) %*% U[tp, -i , ])^2, na.rm = TRUE)
diag(d[tp, ])
U[tp, -i , ]
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
r = 1
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
L = diag(d[tp, ])
L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
Q
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    }       #
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    browser()#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
Time = nrow(theta)#
  R = ncol(d)#
  N = ncol(theta)#
  U = U
E = lapply(1:Time, function(tp) {#
    Y[tp, , ] - XB[[tp]] - outer(theta[tp,], theta[tp,], "+")#
  })
tp = 1
i = 1
L = diag(d[tp, ])
l = L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2
l
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
r = 1
um((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
sum((d[tp, r] * U[tp, -i , r])^2, na.rm = TRUE)
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
diag(R) / tau_r + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2
(diag(R) / tau_r + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2)
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2
E_i = E[[tp]][i, -i]
E_i = E[[tp]][i, -i]
sum(E_i * d[tp, r] * U[tp, -i , r], na.rm = TRUE)
sum(E_i * d[tp, r] * U[tp, -i , r], na.rm = TRUE)
l = matrix(0, Time, R)
l[tp, ] = L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2
l
DUr2 = matrix(0, R, R)
DUr2 = DUr2 + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2
DUr2
DUr2 / tau_r
tau_r
DUr2 / c(1,3)
rcppeigen_invert_matrix(diag(R) / tau_r + DUr2)
diag(R) / tau_r
rcppeigen_invert_matrix(diag(R) / tau_r + DUr2)
rmatrixnorm(l, diag(Time), rcppeigen_invert_matrix(diag(R) / tau_r + DUr2))
?rmatrixnorm
rcppeigen_invert_matrix(diag(R) / tau_r + DUr2)
is.positive.definite(rcppeigen_invert_matrix(diag(R) / tau_r + DUr2))
iQ = rcppeigen_invert_matrix(diag(R) / tau_r + DUr2)
iQ
Time = nrow(theta)#
  R = ncol(d)#
  N = ncol(theta)#
  DUr2 = matrix(0, R, R)#
  l = matrix(0, Time, R)#
  U = U#
  E = lapply(1:Time, function(tp) {#
    Y[tp, , ] - XB[[tp]] - outer(theta[tp,], theta[tp,], "+")#
  })
E
i = 1
for (tp in 1:Time) {#
    			l[tp, ] = L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2#
      		iQ = rcppeigen_invert_matrix(diag(R) / tau_r + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2)#
      		DUr2 = DUr2 + iQ %*% l[tp,]#
      	}
l
tp = 1
l[tp, ] = L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2#
      		iQ = rcppeigen_invert_matrix(diag(R) / tau_r + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2)#
      		DUr2 = DUr2 + iQ %*% l[tp,]
iQ
iQ %*% l[tp,]
l_t= L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2#
      		iQ = rcppeigen_invert_matrix(diag(R) / tau_r + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2)#
      		l[tp, ] = iQ %*% l[tp, ]#
      		DUr2 = DUr2 + iQ
DUr2
l
rmatrixnorm(l, diag(Time), DUr2)
DUr2
is.Symmeteric(DUr2)
is.symmeteric(DUr2)
DUr2[1,2] - DUr2[2,1]
L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L
rmatrixnorm(l, diag(Time), diag(R))
Q
install()
document()
iQ
install()
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    }       #
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    browser()#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
Q
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    }       #
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))

sim
install()
document()
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
DUr2
d
rmatrixnorm(l, diag(Time), DUr2)
Time = nrow(theta)#
  R = ncol(d)#
  N = ncol(theta)#
  U = U#
  E = lapply(1:Time, function(tp) {#
    Y[tp, , ] - XB[[tp]] - outer(theta[tp,], theta[tp,], "+")#
  })
tp = 1
i = 1
L = diag(d[tp, ])
l = L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2#
       iQ = rcppeigen_invert_matrix(diag(R) / tau_r + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2)
l
iQ
Q
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
sim
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
sim
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
sapply(1:Time, function(tp) {rcpp_rmvnorm(1, iQ[[tp]], l[tp, ])})
tp = 1
rcpp_rmvnorm(1, iQ[[tp]], l[tp, ])
i = 1
tp = 1
L = diag(d[tp, ])
l = L %*% (apply(U[tp, , ] * E[[tp]][i, ], 2, sum) - U[tp, i, ] * E[[tp]][i, i]) / s2#
       iQ = rcppeigen_invert_matrix(diag(R) / tau_r + L %*% (crossprod(U[tp, , ]) - U[tp, i, ] %*% t(U[tp, i, ])) %*% L / s2)
iQ %*% l
l[tp, ]
sapply(1:Time, function(tp) {rcpp_rmvnorm(1, iQ[[tp]], l[tp, ])})
Time = nrow(theta)#
  R = ncol(d)#
  N = ncol(theta)#
  iQ = list()#
  l = matrix(0, Time, R)#
  U = U
Q
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
vapply(1:Time, function(tp) {rcpp_rmvnorm(1, iQ[[tp]], l[tp, ])}, rep(1, R))
l
t(vapply(1:Time, function(tp) {rcpp_rmvnorm(1, iQ[[tp]], l[tp, ])}, rep(1, R)))
Q
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
DLFM_init = function(Y, X, RE = c("additive", "multiplicative"), R = 2, dist = "Exponential", gammapriors = c(2, 1), avail = matrix(1, dim(Y)[1], dim(Y)[2]), burn = 1000, nscan = 5000, odens = 100, plot = TRUE, kappas, #
                     beta, theta) {		#
  Time = dim(Y)[1]#
  N = dim(Y)[2]#
  P = dim(X)[4]#
  a = gammapriors[1]; b = gammapriors[2]#
  # construct covariance matrix for each variable#
  dist_ij = c()#
  if (dist == "Exponential"){#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, abs(i-j))#
      }#
    }#
  } else {#
    for (i in 1:Time) {#
      for (j in 1:Time) {#
        dist_ij = c(dist_ij, (i-j)^2)#
      }#
    }#
  }		#
  dist_ij = matrix(dist_ij, nrow = Time, ncol = Time)#
  cinv = lapply(1:(P+2), function(k) {#
    rcppeigen_invert_matrix(Exponential(dist_ij, kappas[k]))#
  })	#
  # select initial values #
  beta = beta#
  d = matrix(0, Time, R)#
  U = array(0, dim = c(Time, N, R))#
  theta = theta#
  BETAPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = P) #
  })#
  UDUPS = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  YPSsum = lapply(1:Time, function(tp) {#
    matrix(0, N, N)#
  })#
  s2PS = matrix(0, nrow = nscan / odens, ncol = 1)#
  tauPS = matrix(0, nrow = nscan / odens, ncol = P + 1 + R)#
  thetaPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N) #
  })#
  UDUstatPS = lapply(1:Time, function(tp) {#
    matrix(0, nrow = nscan / odens, ncol = N * (N-1) / 2)#
  })#
  years = sample(1:Time, 1)#
  # to begin with, use 0 for NA's except meaningful ones#
  colnames(avail) = dimnames(Y)[[2]]#
  meaningful_NA_rows = lapply(1:Time, function(tp) {#
    which(avail[tp,]==0) #
  })#
  meaningful_NA = lapply(1:Time, function(tp) {#
    pre = matrix(0, N, N)#
    pre[meaningful_NA_rows[[tp]],] = NA#
    pre[,meaningful_NA_rows[[tp]]] = NA#
    which(is.na(pre)==TRUE)#
  })#
  meaningful_NA_years = which(vapply(meaningful_NA_rows, function(i) {length(i)}, c(1)) > 0)                 #
  # to begin with, use 0 for NA's#
  for (p in 1:P) {#
    X[, , , p][which(is.na(X[, , , p]))] = 0#
    for (tp in 1:Time) {#
      X[tp, , , p][meaningful_NA[[tp]]] = NA#
    }#
  }#
  XB = lapply(1:Time, function(tp) {#
    Reduce('+', lapply(1:P, function(p){#
      X[tp, , , p] * beta[tp, p]#
    }))#
  })#
  na.positions = lapply(1:Time, function(tp) {#
    which(is.na(Y[tp, , ]))#
  })#
  for (tp in 1:Time) {#
    #mu = mean(Y[tp, , ], na.rm = TRUE) #
    #row = rowMeans(Y[tp, , ] - mu, na.rm = TRUE)#
    #row[is.na(row)] = 0#
    #YA = mu + outer(row, row, "+")#
    #diag(Y[tp, , ]) = 1#
    #Y[tp, , ][na.positions[[tp]]] = YA[na.positions[[tp]]] #
    #Y[tp, , ][meaningful_NA[[tp]]] = NA#
    #diag(Y[tp, , ]) = 0#
    #beta[tp, 1] = mu#
    #theta[tp, ] = row#
  }#
  uppertri = upper.tri(diag(N))#
  s2 = 1#
  tau_r = rep(1/N, R)#
  # starting the Gibbs sampler	#
  for (iter in 1:(burn + nscan)) {#
    if (iter %% 500 == 0) print(iter)#
    tau_p = rtaup_fc(beta, cinv[1:P], a, b)#
    #beta = rbeta_fc(X, beta, theta, UDU, Y, cinv[1:P], tau_p, s2)#
    #XB = lapply(1:Time, function(tp) {#
    #  Reduce('+', lapply(1:P, function(p){#
    #    X[tp, , , p] * beta[tp, p]#
    #  }))#
    #})#
    tau_i = rtaui_fc(theta, cinv[[P+1]], a, b)#
    #theta = rtheta_fc(XB, theta, UDU, Y, cinv[[P+1]], tau_i, s2)#
    #for (tp in meaningful_NA_years) {#
    #  theta[tp, meaningful_NA_rows[[tp]]] = 0#
    #}#
    if (iter > 0.5 * burn) {#
    	tau_r = rtauu_fc(U, a, b)#
    	}#
	U = ru_fc(XB, theta, U, d, Y, tau_r, s2)#
    for (tp in meaningful_NA_years) {#
      U[tp, meaningful_NA_rows[[tp]],] = NA#
    } #
    browser()      #
    d = rd_fc(XB, theta, U, d, Y, cinv[[P+2]], s2, meaningful_NA)#
    UDU = lapply(1:Time, function(tp) {#
      if (R <= 1) {#
        d[tp, ] * U[tp, , ] %*% t(U[tp, ,])#
      } else {#
        U[tp, , ] %*% diag(d[tp, ]) %*% t(U[tp, , ])#
      }#
    })#
    s2 = rs2_fc2(XB, theta, UDU, Y, a, b)#
    if (iter > burn && (iter-burn) %% odens == 0) {     #
      YPS = lapply(1:Time, function(tp) {#
        Errormat = matrix(0, N, N)#
        Errormat[uppertri] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
        YPSmat = Reduce('+', lapply(1:P, function(p) {X[tp, , , p] * beta[tp, p]})) + #
          outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat + t(Errormat)#
        diag(YPSmat) = 0#
        YPSmat#
      })#
      # replace NA's with YPS#
      for (tp in which(vapply(na.positions, function(i) {length(i)}, c(1)) > 0)) {#
        YPS[[tp]][meaningful_NA[[tp]]] = 0#
        Y[tp, , ][na.positions[[tp]]] = YPS[[tp]][na.positions[[tp]]]#
        Y[tp, , ][meaningful_NA[[tp]]] = NA#
      }#
      id = (iter - burn) / odens#
      s2PS[id,] = s2#
      tauPS[id, ] = c(tau_p, tau_i, tau_r)#
      for (tp in 1:Time) {#
        BETAPS[[tp]][id, ] = beta[tp, ]#
        thetaPS[[tp]][id, ] = theta[tp, ]#
        UDUstatPS[[tp]][id, ] = UDU[[tp]][uppertri]#
        UDUPS[[tp]] =  UDUPS[[tp]] + UDU[[tp]]#
        YPSsum[[tp]] = YPSsum[[tp]] + YPS[[tp]]#
      }#
    }#
  }#
  if (plot) {#
    par(mfrow = c(1, 4))#
    matplot(s2PS, type = "l", lty = 1, main = "s2")#
    abline(h = apply(s2PS, 2, median), col = 1:length(s2PS))#
    matplot(BETAPS[[years]], type = "l", lty = 1, col = 1:P, ylab = "BETAPS", main = paste('beta of year = ', years))#
    abline(h = apply(BETAPS[[years]], 2, median), col = 1:P)#
    matplot(rowMeans(thetaPS[[years]]), type = "l", lty = 1, col = 1, ylab = "mean(theta)", main = paste('mean(theta) of year = ', years))#
    abline(h = median(rowMeans(thetaPS[[years]])), col = 1)#
    matplot(rowMeans(UDUstatPS[[years]], na.rm = TRUE), type = "l", lty = 1, ylab = "mean(UDU)", main = paste("mean(UDU) of year = ", years))#
    abline(h = median(rowMeans(UDUstatPS[[years]]), na.rm = TRUE), col = 1)#
  }  #
  UDUPM = lapply(UDUPS, function(x) {#
    x / length(s2PS)#
  })#
  eULU = lapply(1:Time, function(tp) {#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      eigentp = eigen(UDUPM[[tp]][-exclude, -exclude])#
    } else {#
      eigentp = eigen(UDUPM[[tp]])#
    }#
    eigentp#
  })#
  eR = lapply(1:Time, function(tp) {#
    which(rank(-abs(eULU[[tp]]$val), ties.method = "first") <= R)#
  })#
  U =  lapply(1:Time, function(tp) {#
    Uest = eULU[[tp]]$vec[, seq(1, R, length = R), drop = FALSE]#
    exclude = meaningful_NA_rows[[tp]]#
    if (length(exclude) > 0) {#
      rownames(Uest) = rownames(Y[1,,])[-exclude]#
    } else {#
      rownames(Uest) = rownames(Y[1,,])#
    }#
    Uest#
  })#
  L =  lapply(1:Time, function(tp){#
    eULU[[tp]]$val[eR[[tp]]]#
  })#
  YPM = lapply(YPSsum, function(x) {#
    x / length(s2PS)#
  })#
  final = list(YPM = YPM, BETA = BETAPS, theta = thetaPS, UDU = UDUPM, UDUstat = UDUstatPS, #
               U = U, D = L, s2 = s2PS, tau = tauPS)#
  return(final)#
}
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
library(microbenchmark)
microbenchmark(ru_fc(XB, theta, U, d, Y, tau_r, s2), ru_fc2(XB, theta, U, d, Y, tau_r, s2))
Q
document()
install()
library(fields)#
library(matrixStats)#
library(mvtnorm)#
library(FastGP)#
library(LaplacesDemon)#
library(MCMCpack)#
library(DLFM2)#
library(coda)#
nsim =10#
kappas = rep(0.001, 3)#
Time = 25#
N = 30#
R = 2#
dist_ij = c()#
 for (i in 1:Time) {#
 for (j in 1:Time) {#
 dist_ij = c(dist_ij, abs(i-j))#
 }#
 }#
dist_ij = matrix(dist_ij, Time, Time)#
BETA = lapply(1:4, function(m){matrix(0, 1, Time)})#
THETA = lapply(1:4, function(m){matrix(0, N, Time)})#
UDUstat = lapply(1:4, function(m){matrix(0, 2, Time)})#
Error = rep(0, 3)#
Error2 = rep(0, 3)#
Error3 = rep(0, 3)#
Error4 = rep(0, 3)#
#
for (s in 1:nsim){#
print(s)#
    tau_p = 1/rgamma(1, 2, 1)#
    tau_i = 1/rgamma(1, 2, 1)#
	beta = sapply(1:1, function(p){rmvnorm(1, rep(0, Time ), tau_p * matrix(Exponential(dist_ij, kappas[p]), Time, Time, byrow = TRUE))})#
	theta = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), tau_i * matrix(Exponential(dist_ij, kappas[2]), Time, Time, byrow = TRUE))}) #
	U1 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))}) #
	U2 = sapply(1:N, function(i){rmvnorm(1, rep(0, Time ), diag(Time))})#
	U = lapply(1:Time , function(tp){cbind(U1[tp,], U2[tp,])})#
	D = sapply(1:2, function(r){rmvnorm(1, rep(0, Time), matrix(Exponential(dist_ij, kappas[3]), Time, Time, byrow = TRUE))})#
	s2 = 1 / rgamma(1, 2, 1)#
	U2= array(0, dim = c(Time, N, R))#
    for (tp in 1:Time) { U2[tp, , ] = U[[tp]]}#
	UDU = lapply(1:Time , function(tp){U[[tp]] %*% diag(D[tp,]) %*% t(U[[tp]])})#
	UDUstats = t(sapply(1:Time , function(tp){c(sum(UDU[[tp]][upper.tri(UDU[[tp]])]), sd(UDU[[tp]][upper.tri(UDU[[tp]])]))}))#
	Ys = array(NA, dim = c(Time , N, N))#
for (tp in 1:Time ){#
	Errormat = matrix(0, N, N)#
	Errormat[upper.tri(Errormat)] = rnorm(N * (N-1) / 2, 0, sqrt(s2))#
  	Errormat = (Errormat + t(Errormat))#
	Ys[tp, , ] = Reduce("+", lapply(1:1, function(p) {#
                    1 * beta[tp, p]#
                  })) + outer(theta[tp, ], theta[tp, ], "+") + UDU[[tp]] + Errormat#
	diag(Ys[tp,,]) = 0                  #
}#
Xnew = array(1, dim = c(Time , N, N, 1))#
set.seed(s)#
# M1 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(0.001, 3))#
# set.seed(s)#
# M2 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(1, 3))#
# set.seed(s)#
# M3 = DLFM_fix(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 1000, nscan = 6000, odens = 12, plot =FALSE, kappas = rep(5, 3))#
# set.seed(s)#
M4 = DLFM_init(Ys, Xnew, RE = c("additive", "multiplicative"), gammapriors = rep(c(2, 1), 5), dist = "Exponential", avail = matrix(1, Time , N), R =2, burn = 100, nscan = 600, odens = 1, plot =FALSE, kappas = rep(0.001, 3),  #
               beta, theta)#
#coverage probability#
# M1_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M1$BETA[[t]]))[1,]})#
# BETA[[1]] = BETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_BETA[[t]][1]<= beta[t,] & M1_BETA[[t]][2]>= beta[t,])})#
# M1_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M1$theta[[t]]))[1:N,]})#
# THETA[[1]] = THETA[[1]] + sapply(1:Time, function(t){as.numeric(M1_theta[[t]][,1]<= theta[t,] & M1_theta[[t]][,2]>= theta[t,])})#
# M1_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M1$UDUstat[[t]]), rowSds(M1$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[1]] = UDUstat[[1]] + sapply(1:Time, function(t){as.numeric(M1_UDU[[t]][,1]<= UDUstats[t,] & M1_UDU[[t]][,2]>= UDUstats[t,])})#
# Error[1] = Error[1] + as.numeric(HPDinterval(mcmc(M1$s2))[1,1]<= s2 & HPDinterval(mcmc(M1$s2))[1,2]>= s2)#
# Error[2] = Error[2] + as.numeric(HPDinterval(mcmc(M1$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M1$tau[,1]))[,2]>= tau_p)#
# Error[3] = Error[3] + as.numeric(HPDinterval(mcmc(M1$tau[,2]))[,1]<= tau_i &HPDinterval(mcmc(M1$tau[,2]))[,2]>= tau_i)#
#
# M2_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M2$BETA[[t]]))[1,]})#
# BETA[[2]] = BETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_BETA[[t]][1]<= beta[t,] & M2_BETA[[t]][2]>= beta[t,])})#
# M2_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M2$theta[[t]]))[1:N,]})#
# THETA[[2]] = THETA[[2]] + sapply(1:Time, function(t){as.numeric(M2_theta[[t]][,1]<= theta[t,] & M2_theta[[t]][,2]>= theta[t,])})#
# M2_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M2$UDUstat[[t]]), rowSds(M2$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[2]] = UDUstat[[2]] + sapply(1:Time, function(t){as.numeric(M2_UDU[[t]][,1]<= UDUstats[t,] & M2_UDU[[t]][,2]>= UDUstats[t,])})#
# Error2[1] = Error2[1] + as.numeric(HPDinterval(mcmc(M2$s2))[1,1]<= s2 & HPDinterval(mcmc(M2$s2))[1,2]>= s2)#
# Error2[2] = Error2[2] + as.numeric(HPDinterval(mcmc(M2$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M2$tau[,1]))[,2]>= tau_p) #
# Error2[3] = Error2[3] + as.numeric(HPDinterval(mcmc(M2$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M2$tau[,2]))[,2]>= tau_i)#
#
# M3_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M3$BETA[[t]]))[1,]})#
# BETA[[3]] = BETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_BETA[[t]][1]<= beta[t,] & M3_BETA[[t]][2]>= beta[t,])})#
# M3_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M3$theta[[t]]))[1:N,]})#
# THETA[[3]] = THETA[[3]] + sapply(1:Time, function(t){as.numeric(M3_theta[[t]][,1]<= theta[t,] & M3_theta[[t]][,2]>= theta[t,])})#
# M3_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M3$UDUstat[[t]]), rowSds(M3$UDUstat[[t]]))))[1:2,]})#
# UDUstat[[3]] = UDUstat[[3]] + sapply(1:Time, function(t){as.numeric(M3_UDU[[t]][,1]<= UDUstats[t,] & M3_UDU[[t]][,2]>= UDUstats[t,])})#
# Error3[1] = Error3[1] + as.numeric(HPDinterval(mcmc(M3$s2))[1,1]<= s2 & HPDinterval(mcmc(M3$s2))[1,2]>= s2)#
# Error3[2] = Error3[2] + as.numeric(HPDinterval(mcmc(M3$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M3$tau[,1]))[,2]>= tau_p) #
# Error3[3] = Error3[3] + as.numeric(HPDinterval(mcmc(M3$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M3$tau[,2]))[,2]>= tau_i)#
#
M4_BETA = lapply(1:Time, function(t){HPDinterval(mcmc(M4$BETA[[t]]))[1,]})#
BETA[[4]] = BETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_BETA[[t]][1]<= beta[t,] & M4_BETA[[t]][2]>= beta[t,])})#
M4_theta = lapply(1:Time, function(t){HPDinterval(mcmc(M4$theta[[t]]))[1:N,]})#
THETA[[4]] = THETA[[4]] + sapply(1:Time, function(t){as.numeric(M4_theta[[t]][,1]<= theta[t,] & M4_theta[[t]][,2]>= theta[t,])})#
M4_UDU = lapply(1:Time, function(t){HPDinterval(mcmc(cbind(rowSums(M4$UDUstat[[t]]), rowSds(M4$UDUstat[[t]]))))[1:2,]})#
UDUstat[[4]] = UDUstat[[4]] + sapply(1:Time, function(t){as.numeric(M4_UDU[[t]][,1]<= UDUstats[t,] & M4_UDU[[t]][,2]>= UDUstats[t,])})#
Error4[1] = Error4[1] + as.numeric(HPDinterval(mcmc(M4$s2))[1,1]<= s2 & HPDinterval(mcmc(M4$s2))[1,2]>= s2)#
Error4[2] = Error4[2] + as.numeric(HPDinterval(mcmc(M4$tau[,1]))[,1]<= tau_p & HPDinterval(mcmc(M4$tau[,1]))[,2]>= tau_p) #
Error4[3] = Error4[3] + as.numeric(HPDinterval(mcmc(M4$tau[,2]))[,1]<= tau_i & HPDinterval(mcmc(M4$tau[,2]))[,2]>= tau_i)#
}#
sim = list(BETA = BETA, THETA = THETA, UDU = UDUstat, Var = rbind(Error, Error2, Error3, Error4))
document()
document()
check()
document()
check()
document()
check()
document()
check()
install()
document()
install()
